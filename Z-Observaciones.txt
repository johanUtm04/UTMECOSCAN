# 1ï¸âƒ£ Ver en quÃ© rama estÃ¡s
git branch

# 2ï¸âƒ£ Ver cambios locales
git status

# 3ï¸âƒ£ Traer info del remoto sin hacer merge
git fetch
git status

# 4ï¸âƒ£ Comparar tu rama con el remoto
git log origin/main..HEAD      # commits locales que no estÃ¡n en remoto
git log HEAD..origin/main      # commits remotos que no tienes

# 5ï¸âƒ£ Traer cambios del remoto y actualizar tu rama
git pull

# 6ï¸âƒ£ Ver todos los remotos configurados
git remote -v

# 7ï¸âƒ£ Ver diferencias entre local y remoto
git diff origin/main

# 8ï¸âƒ£ Preparar archivos para commit (aÃ±adir cambios)
git add .                      # aÃ±ade todos los cambios
# o git add <archivo>          # aÃ±ade solo un archivo especÃ­fico

# 9ï¸âƒ£ Hacer commit
git commit -m "Mensaje de tu commit"

# ğŸ”Ÿ Subir cambios al remoto
git push

Link firebase:
https://console.firebase.google.com/u/0/project/contaminacion-en-el-aire-utm/overview

Usuarios base de datos
https://console.firebase.google.com/u/0/project/contaminacion-en-el-aire-utm/authentication/users

Codigo Creado...
main.tsx---->  App.stx / auth.ts---->

Efecto de prueba, en caso de no tener el Sensor...
probar Tablero
const [lecturas, setLecturas] = useState<Lectura[]>([]);

//UseEffect de Prueba(en caso de no tener disponibilidad de conectar algun sensor) ğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µ
useEffect(() => {
  const fetchData = async () => {
    try {
      // Lista de sensores de ejemplo
      const sensores = ["PM2.5", "Temperatura","CO2"];

      // Generamos un sensor aleatorio
      const data = {
        sensor: sensores[Math.floor(Math.random() * sensores.length)],
        pm25: Math.floor(Math.random() * 100), // valor aleatorio entre 0-99
      };

      // Creamos un objeto nuevaLectura siguiendo la interfaz Lectura
      const nuevaLectura: Lectura = {
        timestamp: Timestamp.now(),
        id: Date.now().toString(), // id Ãºnico
        sensor: data.sensor,
        valor: data.pm25,
      };

      // Agregamos la lectura al estado (sin borrar las anteriores)
      setLecturas((estadoAnterior) => [...estadoAnterior, nuevaLectura]);

      //Nuevo paso: ğŸ”¥
      await addDoc(collection(db, "lecturas-Fake"),{
      sensor: data.sensor,
      valor: data.pm25,
      timestamp: nuevaLectura.timestamp,
      salon: "Aula 1",
      userId: user?.uid, });

    } catch (err) {
      console.error("Error al generar datos:", err);
    }
  };
  // Llamamos cada 5 segundos para simular lecturas continuas
  const interval = setInterval(fetchData, 5000);
  return () => clearInterval(interval);
}, []);
//UseEffect de Prueba(en caso de no tener disponibilidad de conectar algun sensor) ğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µğŸ¥µ


Codigo de Tablero que si funciona: âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨
 // React
import React, { useEffect, useState } from "react";

// Material UI
import Card from "@mui/material/Card";
import CardContent from "@mui/material/CardContent";
import CardHeader from "@mui/material/CardHeader";
import Typography from "@mui/material/Typography";

//Importaciones para FireStore ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
import { collection, addDoc, Timestamp, where, getDocs, query } from "firebase/firestore";
import { db } from "../firebase";

// Tipos
interface TABLERO {
  user: any; 
}

interface Lectura {
  timestamp: Timestamp;
  id: string;
  sensor: string;
  valor: number;
}

const Tablero: React.FC<TABLERO> = ({ user }) => {
const [lecturas, setLecturas] = useState<Lectura[]>([]);
const [fechaSeleccionada, setFechaSeleccionada] = useState<Date | null > (null);


//Consultar por fecha 2.-
const buscarPorFecha = async () => {
  if(!fechaSeleccionada) return;
  const datos = await getLecturasPorDia(fechaSeleccionada);
  setLecturas(datos);
}

async function getLecturasPorDia (fecha: Date){
  //Inicio del dÃ­a
  const inicio = new Date(fecha);
  inicio.setHours(0,0,0,0);

  //fin del dÃ­a
  const fin = new Date(fecha);
  fin.setHours(23,59,59,999);

  //armamos el query --La receta que quieres buscar
  const q = query (
    collection(db, "lecturas"),
    where("timestamp", ">=", Timestamp.fromDate(inicio)),
    where("timestamp", "<=", Timestamp.fromDate(fin))
  );

  //Ejecutamos el query, es decir, la consulta --Vas al refri y traes los alimentos segun la receta
  const querySnapshot = await getDocs(q);

  //Inicializacion de un arreglo vacio const resultados: any[]=[];
  const resultados: any[]=[];

    //Recorremos cada elemento de la consulta query
  querySnapshot.forEach((doc)=>{
      //Los meteremos en el array resultados
    resultados.push({id: doc.id, ...doc.data()});
          /*Ejemplo resultados quedaria algo asi:
          [
            {id:1, Timestamp: 12-may-35, valor:28},
            {}, {}, {}
          ] */

    //Escribimos en consola estos datos
    console.log(doc.id, doc.data().timestamp.toDate());
  })
  return resultados;
};

   useEffect(() => {
    //Funcion Asincronada (puede hacer coas que tardan en completarse)
    const fetchData = async () => {
      try {
        /* Con await, esperamos a que sea conectado el esp32 */
        const res = await fetch("http://192.168.1.97/data-json"); 
        //Convertimos los datos en un objeto JavaScript (Json)
        const data = await res.json();
        // Adaptamos el JSON a la interfaz Lectura[]
        //Creamos Una instancia del objeto "lectura"
        const nuevaLectura: Lectura = {
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: data.sensor,
          valor: data.pm25,
        };
        //Ir encadenando lecturas una atras de otra
        setLecturas((prev) => [...prev, nuevaLectura]); 
      } catch (err) {
        console.error("Error al obtener datos:", err);
      }
    };

    // Llamamos cada 5 segundos
    const interval = setInterval(fetchData, 5000);
    return () => clearInterval(interval);
  }, []);

//UsEffect para traer Datos y almacenarlos en fireStore

return (
  //Div principal.
  <div style={{ padding: "20px" }}>
    <div
      style={{
        marginBottom: "20px",
        padding: "20px",
        borderRadius: "20px",
        background: "rgba(255, 255, 255, 0.15)",
        backdropFilter: "blur(12px)",
        border: "3px solid rgba(0, 0, 0, 0.3)",
        color: "white",
        textAlign: "center",
      }}
    >
      <h2 style={{ marginBottom: "10px", color:"black", fontWeight:700 }}>
       Sistema de MediciÃ³n de Calidad del Aire 
      </h2>
      <p style={{ fontSize: "16px", lineHeight: "1.5", color:"black" }}>
        Este experimento tiene como objetivo medir la concentraciÃ³n de partÃ­culas 
        en el aire utilizando sensores conectados a un ESP32.  
        Los datos recolectados son procesados en tiempo real y se muestran en este tablero.
      </p>
    </div>

    {/* Consultar por fecha 1.- */}
    <div>
      <h2>Historial de Lecturas</h2>
      <input type="date"
        onChange={(e) => {
          const value = e.target.value; // "2025-09-14"
          const [year, month, day] = value.split("-").map(Number);
          // ğŸ‘‡ Crear la fecha en la zona local, no UTC
          setFechaSeleccionada(new Date(year, month - 1, day));
        }}
      />
      <button onClick={buscarPorFecha}>Buscar</button>
      |{/* Resultados */}
      <ul>
        {lecturas.map((l) => (
          <li key={l.id}>
            {l.sensor} =&rbrace; {l.valor} ({l.timestamp.toDate().toLocaleString()})
          </li>
        ))}
      </ul>
    </div>

    {lecturas.length === 0 ? (
      <Typography variant="h4" color="#000000ff" fontWeight={600}>
        No hay datos aÃºn.
      </Typography>
    ) : (
      <div
        style={{
          display: "flex",
          flexWrap: "wrap",
          gap: "15px",
          padding: "10px",
        }}
      >
        {lecturas.map((l) => (
          <Card
            key={l.id}
            sx={{
              width: 200,
              borderRadius: 2,
              boxShadow: 3,
              background: "rgba(255, 255, 255, 0.15)",
              backdropFilter: "blur(10px)",
              border: "1px solid rgba(255,255,255,0.3)",
            }}
          > 
            <CardHeader title={l.sensor} sx={{ color: "#000000ff" }} />
            <CardContent>
              <Typography variant="h5" sx={{ color: "#000000ff" }}>
                {l.valor} 
              </Typography>
              <Typography variant="body2" sx={{ color: "#000000ff" }}>
                Ãšltima actualizaciÃ³n 
              </Typography>
            </CardContent>
          </Card>
        ))}
      </div>
    )}
  </div>
);

};

export default Tablero;


Codigo de Tablero que si funciona(es una respaldo antiguo): âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨âœ¨


Codigo Axel VersiÃ³n1 (Arduino)ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘:

#include <Wire.h>
#include <WiFi.h>
#include <WebServer.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

// --- ConfiguraciÃ³n Wi-Fi ---
const char* ssid = "INFINITUM7BB2";   // tu red WiFi
const char* password = "wvdK4gYDpW";  // tu contraseÃ±a

// --- Servidor Web ---
  //WebServer es una clase (objeto) de la libreria "WebServer"
WebServer server(80); //Trabajaremos en el puerto 80

// --- BME280 ---
Adafruit_BME280 bme;  // objeto sensor
#define SEALEVELPRESSURE_HPA (1013.25) // presiÃ³n nivel del mar

// --- FunciÃ³n que devuelve datos en JSON ---
  //void -> la funcion no devuelve nada ni recibe parametros ()
    //Nombre de la funcion
void handleDataJSON() {
  //server->Nuestro objeto servidor
    //.sendHeader -> envia una cabecera HTTP
      //Permite peticiones desde cualquier origen
  server.sendHeader("Access-Control-Allow-Origin", "*"); // CORS libre
  //String es un tipo de variable para manejar texto dinamico
    //json es nombre de la variable 
      //Empieza el Json con un llave
  String json = "{";
  //Lineas que van ir  construyendo el Json âº
    // += Agrega texto al string json
    //\"sensor\" esto es como escribir "sensor" (las comillas se escapan con \)
    //: en json significa clave-valor
    //BME280 es el valor que tendra sensor
  json += "\"sensor\":\"Temperatura\",";
    //bme.raedtEMPERATURE() este llama al sensor y devuelve un numero flotante(Â°C)
      //String(...) convierte ese numero en texto
  json += "\"temperature\":" + String(bme.readTemperature()) + ",";
    //llama al sensr pero para humedad
  json += "\"humidity\":" + String(bme.readHumidity()) + ",";
    //llama al sensor pero presion, en pascales y a su ves a hectopascales
  json += "\"pressure\":" + String(bme.readPressure() / 100.0F) + ",";
    //Lo mismo que las anteriores pero calcula la altitud aproximada usando la presiÃ³n actual y la de referencia
  json += "\"altitude\":" + String(bme.readAltitude(SEALEVELPRESSURE_HPA));
  json += "}"; //cierre del json
  //Envia respuesta http, con el tipo de contenido que es json
  server.send(200, "application/json", json);
}

//Setup (Funcion que solo arranca una vez)
void setup() {
  //Inicia la comunicacion serial con la pc, a una velocidad de 115200
  Serial.begin(115200);
  //espera un milisegundo
  delay(1000);

  // --- ConexiÃ³n Wi-Fi ---
  WiFi.begin(ssid, password); //Conectar con credenciales 
  Serial.println("Conectando a WiFi..."); //Escribe en la pantalla serial
  //Mientras no estemos conectaods al wifi, se repite el codigo de las llaves
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  //Una Vez esta conectado, nos muestra en pantalla esto:
  Serial.println("\nWiFi conectado!");
  Serial.print("IP del ESP32: "); Serial.println(WiFi.localIP());

  // --- Inicializar BME280 ---
  //Wire se encarga de manejar la comunicaciÃ³n I2C (bus de 2 cables)
  Wire.begin(19, 18); //SDA = 19, SCL = 18
if (!bme.begin(0x76, &Wire)) {  
  if (!bme.begin(0x77, &Wire)) {
    Serial.println("No se encontrÃ³ el BME280 en 0x76 ni 0x77");
    while (1);
  }
}

//Mostramos en pantalla si se conecta correctamente el sig msj
  Serial.println("BME280 inicializado correctamente");

  // --- Configurar servidor ---
  server.on("/data-json", handleDataJSON); //Ruta donde se inicia esta funciÃ³n 
  server.begin(); //Arranca el servidor
  Serial.println("Servidor web iniciado en puerto 80"); //Imprime en el monitor serie el msj
}

//Funcion que no devuelve nada y esta en loop
void loop() {
  server.handleClient(); // Revisa si alguien entro al servidor
  // Muestra datos en Serial cada segundo (debug)
  Serial.print("Temp: "); Serial.print(bme.readTemperature()); Serial.print(" Â°C, ");
  Serial.print("Hum: "); Serial.print(bme.readHumidity()); Serial.print(" %, ");
  Serial.print("PresiÃ³n: "); Serial.print(bme.readPressure() / 100.0F); Serial.println(" hPa");
  delay(1000);
}
Codigo Axel VersiÃ³n1 (Arduino)ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘ğŸ›‘:



Codigo de Johan (Arduino)ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸
#include <WiFi.h>
#include <WebServer.h>
#include <HardwareSerial.h>

// --- Wi-Fi ---
const char* ssid = "INFINITUM7BB2";
const char* password = "wvdK4gYDpW";

// --- Servidor web ---
WebServer server(80);

// --- PMS5003 ---
HardwareSerial pmsSerial(1);
#define PMS_RX 44
#define PMS_TX 43

struct pms5003data {
  uint16_t framelen;
  uint16_t pm10_standard, pm25_standard, pm100_standard;
  uint16_t pm10_env, pm25_env, pm100_env;
  uint16_t particles_03um, particles_05um, particles_10um, particles_25um, particles_50um, particles_100um;
  uint16_t unused;
  uint16_t checksum;
};

struct pms5003data data;

// --- FunciÃ³n que devuelve datos en JSON ---
void handleDataJSON() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  String json = "{";
  json += "\"sensor\":\"PMS5003\",";
  json += "\"pm25\":" + String(data.pm25_standard) + ",";
  json += "\"pm10\":" + String(data.pm100_standard) + ",";
  json += "\"particles_03um\":" + String(data.particles_03um) + ",";
  json += "\"particles_05um\":" + String(data.particles_05um) + ",";
  json += "\"particles_10um\":" + String(data.particles_10um) + ",";
  json += "\"particles_25um\":" + String(data.particles_25um) + ",";
  json += "\"particles_50um\":" + String(data.particles_50um) + ",";
  json += "\"particles_100um\":" + String(data.particles_100um);
  json += "}";
  server.send(200, "application/json", json);
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Conectar Wi-Fi
  WiFi.begin(ssid, password);
  Serial.println("Conectando a Wi-Fi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConectado!");
  Serial.print("IP asignada: "); Serial.println(WiFi.localIP());

  // Configurar servidor
  server.on("/data-json", handleDataJSON);
  server.begin();
  Serial.println("Servidor web iniciado");

  // Inicializar PMS5003
  pmsSerial.begin(9600, SERIAL_8N1, PMS_RX, PMS_TX);
  Serial.println("Esperando datos del PMS5003...");
}

void loop() {
  server.handleClient(); // Atiende solicitudes web

  // Leer PMS5003
  if (readPMSdata(&pmsSerial)) {
    Serial.print("\rPM2.5: "); Serial.print(data.pm25_standard);
    Serial.print("  PM10: "); Serial.print(data.pm100_standard);
    Serial.print("  Part >0.3um: "); Serial.print(data.particles_03um);
    Serial.print("  Part >0.5um: "); Serial.print(data.particles_05um);
    Serial.print("  Part >1.0um: "); Serial.print(data.particles_10um);
    Serial.print("  Part >2.5um: "); Serial.print(data.particles_25um);
    Serial.print("  Part >5.0um: "); Serial.print(data.particles_50um);
    Serial.print("  Part >10um: "); Serial.print(data.particles_100um);
  }

  delay(1000);
}

// --- FunciÃ³n de lectura PMS5003 ---
boolean readPMSdata(Stream *s) {
  if (!s->available()) return false;
  if (s->peek() != 0x42) { s->read(); return false; }
  if (s->available() < 32) return false;

  uint8_t buffer[32];
  uint16_t sum = 0;
  s->readBytes(buffer, 32);

  for (uint8_t i = 0; i < 30; i++) sum += buffer[i];

  uint16_t buffer_u16[15];
  for (uint8_t i = 0; i < 15; i++) {
    buffer_u16[i] = buffer[2 + i*2 + 1];
    buffer_u16[i] += (buffer[2 + i*2] << 8);
  }

  memcpy((void *)&data, (void *)buffer_u16, 30);

  if (sum != data.checksum) {
    Serial.println("Checksum failure");
    return false;
  }

  return true;
}
Codigo de Johan (Arduino)ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸ğŸš¸


UseEffect para sensores ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥

//Use Effect Johan ----
   useEffect(() => {
    //Funcion Asincronada (puede hacer coas que tardan en completarse)
        const fetchData = async () => {
        try {
        /* Con await, esperamos a que sea conectado el esp32 */
        const res = await fetch("http://192.168.1.97/data-json"); 
        //Convertimos los datos en un objeto JavaScript (Json)
        const data = await res.json();
        // Adaptamos el JSON a la interfaz Lectura[]
        //Creamos Una instancia del objeto "lectura"
        const nuevaLectura: Lectura = {
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: data.sensor,
          valor: data.pm25,
        };
        //Ir encadenando lecturas una atras de otra
        setLecturas((prev) => [...prev, nuevaLectura]); 
        await addDoc(collection(db,"lecturas"),{
        sensor: data.sensor, 
        valor: data.pm25,
        timestamp: nuevaLectura.timestamp,
        salon: "Salon A10",
        userId: user?.uid,
      }); 
      } catch (err) {
        console.error("Error al obtener datos:", err);
      }
    };
    // Llamamos cada 5 segundos
    const interval = setInterval(fetchData, 3000);
    return () => clearInterval(interval);
  }, []);


  //Use Effect Axel ----
  useEffect(()=>{
    const fetchData = async () =>{
      try {
        //Constante para conectarnos a la url del esp32
        const conexion = await fetch ("http://192.168.1.97/data-json");
        const dataBM280 = await conexion.json();

        const nuevaLecturaBM280: Lectura  ={
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: dataBM280.sensor,
          valor: dataBM280.temperature,
        };

        //Ir encadenanado Lecturas
        setLecturas(
          (prev) => [...prev, nuevaLecturaBM280]
        );

        //Agregar Lecturas a la coleccion:
        await addDoc(collection(db, "lecturasBM280"),{
          //Campos de la coleccion
          sensor: dataBM280.sensor,
          valor: dataBM280.temperature,
          Timestamp: nuevaLecturaBM280.timestamp,
          Lugar: "Morelia",
          userID: user?.uid,
        });
      } catch (error) {
        console.log("ocurrio un error caballero, es el siguiente: ", error);
      }
    };
    //Llamamos useEffect cada 5 segundos
    const interval = setInterval(fetchData, 3000);
    return () => clearInterval(interval);
  },[])

UseEffect para sensores ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥ğŸ˜ˆğŸ”¥


Tareas Pendientes...ã€½ã€½ã€½
UseEffect Sensor de Temperatura... âœ”
Alternar Entre UsEffects y botones para mostrar Tarjetasâœ”
Cambiar console.log a promps o alerts para que usuario sepa que pasa...âœ”
Boton de detener lecturas ...âœ”
Estilizar barra fea abajo de botones xD...âœ”
Agregar Columna para mencionarle al usuario como van las cosasâœ”
Refactorizar Codigo...
Botones Tomen Todo el color que les corresponde...
Footer



//instracciones para instalacion
0.-Descargar git
1.- Instalar el Node.js(Almenos la version 20)
2.- Ingresar en la terminal el npm run dev 
