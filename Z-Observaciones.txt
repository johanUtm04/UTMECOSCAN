# 1️⃣ Ver en qué rama estás
git branch

# 2️⃣ Ver cambios locales
git status

# 3️⃣ Traer info del remoto sin hacer merge
git fetch
git status

# 4️⃣ Comparar tu rama con el remoto
git log origin/main..HEAD      # commits locales que no están en remoto
git log HEAD..origin/main      # commits remotos que no tienes

# 5️⃣ Traer cambios del remoto y actualizar tu rama
git pull

# 6️⃣ Ver todos los remotos configurados
git remote -v

# 7️⃣ Ver diferencias entre local y remoto
git diff origin/main

# 8️⃣ Preparar archivos para commit (añadir cambios)
git add .                      # añade todos los cambios
# o git add <archivo>          # añade solo un archivo específico

# 9️⃣ Hacer commit
git commit -m "Mensaje de tu commit"

# 🔟 Subir cambios al remoto
git push

Link firebase:
https://console.firebase.google.com/u/0/project/contaminacion-en-el-aire-utm/overview

Usuarios base de datos
https://console.firebase.google.com/u/0/project/contaminacion-en-el-aire-utm/authentication/users

Codigo Creado...
main.tsx---->  App.stx / auth.ts---->

Efecto de prueba, en caso de no tener el Sensor...
probar Tablero
const [lecturas, setLecturas] = useState<Lectura[]>([]);

//UseEffect de Prueba(en caso de no tener disponibilidad de conectar algun sensor) 🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵
useEffect(() => {
  const fetchData = async () => {
    try {
      // Lista de sensores de ejemplo
      const sensores = ["PM2.5", "Temperatura","CO2"];

      // Generamos un sensor aleatorio
      const data = {
        sensor: sensores[Math.floor(Math.random() * sensores.length)],
        pm25: Math.floor(Math.random() * 100), // valor aleatorio entre 0-99
      };

      // Creamos un objeto nuevaLectura siguiendo la interfaz Lectura
      const nuevaLectura: Lectura = {
        timestamp: Timestamp.now(),
        id: Date.now().toString(), // id único
        sensor: data.sensor,
        valor: data.pm25,
      };

      // Agregamos la lectura al estado (sin borrar las anteriores)
      setLecturas((estadoAnterior) => [...estadoAnterior, nuevaLectura]);

      //Nuevo paso: 🔥
      await addDoc(collection(db, "lecturas-Fake"),{
      sensor: data.sensor,
      valor: data.pm25,
      timestamp: nuevaLectura.timestamp,
      salon: "Aula 1",
      userId: user?.uid, });

    } catch (err) {
      console.error("Error al generar datos:", err);
    }
  };
  // Llamamos cada 5 segundos para simular lecturas continuas
  const interval = setInterval(fetchData, 5000);
  return () => clearInterval(interval);
}, []);
//UseEffect de Prueba(en caso de no tener disponibilidad de conectar algun sensor) 🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵🥵


Codigo de Tablero que si funciona: ✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨
 // React
import React, { useEffect, useState } from "react";

// Material UI
import Card from "@mui/material/Card";
import CardContent from "@mui/material/CardContent";
import CardHeader from "@mui/material/CardHeader";
import Typography from "@mui/material/Typography";

//Importaciones para FireStore 🔥🔥🔥🔥🔥
import { collection, addDoc, Timestamp, where, getDocs, query } from "firebase/firestore";
import { db } from "../firebase";

// Tipos
interface TABLERO {
  user: any; 
}

interface Lectura {
  timestamp: Timestamp;
  id: string;
  sensor: string;
  valor: number;
}

const Tablero: React.FC<TABLERO> = ({ user }) => {
const [lecturas, setLecturas] = useState<Lectura[]>([]);
const [fechaSeleccionada, setFechaSeleccionada] = useState<Date | null > (null);


//Consultar por fecha 2.-
const buscarPorFecha = async () => {
  if(!fechaSeleccionada) return;
  const datos = await getLecturasPorDia(fechaSeleccionada);
  setLecturas(datos);
}

async function getLecturasPorDia (fecha: Date){
  //Inicio del día
  const inicio = new Date(fecha);
  inicio.setHours(0,0,0,0);

  //fin del día
  const fin = new Date(fecha);
  fin.setHours(23,59,59,999);

  //armamos el query --La receta que quieres buscar
  const q = query (
    collection(db, "lecturas"),
    where("timestamp", ">=", Timestamp.fromDate(inicio)),
    where("timestamp", "<=", Timestamp.fromDate(fin))
  );

  //Ejecutamos el query, es decir, la consulta --Vas al refri y traes los alimentos segun la receta
  const querySnapshot = await getDocs(q);

  //Inicializacion de un arreglo vacio const resultados: any[]=[];
  const resultados: any[]=[];

    //Recorremos cada elemento de la consulta query
  querySnapshot.forEach((doc)=>{
      //Los meteremos en el array resultados
    resultados.push({id: doc.id, ...doc.data()});
          /*Ejemplo resultados quedaria algo asi:
          [
            {id:1, Timestamp: 12-may-35, valor:28},
            {}, {}, {}
          ] */

    //Escribimos en consola estos datos
    console.log(doc.id, doc.data().timestamp.toDate());
  })
  return resultados;
};

   useEffect(() => {
    //Funcion Asincronada (puede hacer coas que tardan en completarse)
    const fetchData = async () => {
      try {
        /* Con await, esperamos a que sea conectado el esp32 */
        const res = await fetch("http://192.168.1.97/data-json"); 
        //Convertimos los datos en un objeto JavaScript (Json)
        const data = await res.json();
        // Adaptamos el JSON a la interfaz Lectura[]
        //Creamos Una instancia del objeto "lectura"
        const nuevaLectura: Lectura = {
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: data.sensor,
          valor: data.pm25,
        };
        //Ir encadenando lecturas una atras de otra
        setLecturas((prev) => [...prev, nuevaLectura]); 
      } catch (err) {
        console.error("Error al obtener datos:", err);
      }
    };

    // Llamamos cada 5 segundos
    const interval = setInterval(fetchData, 5000);
    return () => clearInterval(interval);
  }, []);

//UsEffect para traer Datos y almacenarlos en fireStore

return (
  //Div principal.
  <div style={{ padding: "20px" }}>
    <div
      style={{
        marginBottom: "20px",
        padding: "20px",
        borderRadius: "20px",
        background: "rgba(255, 255, 255, 0.15)",
        backdropFilter: "blur(12px)",
        border: "3px solid rgba(0, 0, 0, 0.3)",
        color: "white",
        textAlign: "center",
      }}
    >
      <h2 style={{ marginBottom: "10px", color:"black", fontWeight:700 }}>
       Sistema de Medición de Calidad del Aire 
      </h2>
      <p style={{ fontSize: "16px", lineHeight: "1.5", color:"black" }}>
        Este experimento tiene como objetivo medir la concentración de partículas 
        en el aire utilizando sensores conectados a un ESP32.  
        Los datos recolectados son procesados en tiempo real y se muestran en este tablero.
      </p>
    </div>

    {/* Consultar por fecha 1.- */}
    <div>
      <h2>Historial de Lecturas</h2>
      <input type="date"
        onChange={(e) => {
          const value = e.target.value; // "2025-09-14"
          const [year, month, day] = value.split("-").map(Number);
          // 👇 Crear la fecha en la zona local, no UTC
          setFechaSeleccionada(new Date(year, month - 1, day));
        }}
      />
      <button onClick={buscarPorFecha}>Buscar</button>
      |{/* Resultados */}
      <ul>
        {lecturas.map((l) => (
          <li key={l.id}>
            {l.sensor} =&rbrace; {l.valor} ({l.timestamp.toDate().toLocaleString()})
          </li>
        ))}
      </ul>
    </div>

    {lecturas.length === 0 ? (
      <Typography variant="h4" color="#000000ff" fontWeight={600}>
        No hay datos aún.
      </Typography>
    ) : (
      <div
        style={{
          display: "flex",
          flexWrap: "wrap",
          gap: "15px",
          padding: "10px",
        }}
      >
        {lecturas.map((l) => (
          <Card
            key={l.id}
            sx={{
              width: 200,
              borderRadius: 2,
              boxShadow: 3,
              background: "rgba(255, 255, 255, 0.15)",
              backdropFilter: "blur(10px)",
              border: "1px solid rgba(255,255,255,0.3)",
            }}
          > 
            <CardHeader title={l.sensor} sx={{ color: "#000000ff" }} />
            <CardContent>
              <Typography variant="h5" sx={{ color: "#000000ff" }}>
                {l.valor} 
              </Typography>
              <Typography variant="body2" sx={{ color: "#000000ff" }}>
                Última actualización 
              </Typography>
            </CardContent>
          </Card>
        ))}
      </div>
    )}
  </div>
);

};

export default Tablero;


Codigo de Tablero que si funciona(es una respaldo antiguo): ✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨✨


Codigo Axel Versión1 (Arduino)🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑:

#include <Wire.h>
#include <WiFi.h>
#include <WebServer.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

// --- Configuración Wi-Fi ---
const char* ssid = "INFINITUM7BB2";   // tu red WiFi
const char* password = "wvdK4gYDpW";  // tu contraseña

// --- Servidor Web ---
  //WebServer es una clase (objeto) de la libreria "WebServer"
WebServer server(80); //Trabajaremos en el puerto 80

// --- BME280 ---
Adafruit_BME280 bme;  // objeto sensor
#define SEALEVELPRESSURE_HPA (1013.25) // presión nivel del mar

// --- Función que devuelve datos en JSON ---
  //void -> la funcion no devuelve nada ni recibe parametros ()
    //Nombre de la funcion
void handleDataJSON() {
  //server->Nuestro objeto servidor
    //.sendHeader -> envia una cabecera HTTP
      //Permite peticiones desde cualquier origen
  server.sendHeader("Access-Control-Allow-Origin", "*"); // CORS libre
  //String es un tipo de variable para manejar texto dinamico
    //json es nombre de la variable 
      //Empieza el Json con un llave
  String json = "{";
  //Lineas que van ir  construyendo el Json ⏺
    // += Agrega texto al string json
    //\"sensor\" esto es como escribir "sensor" (las comillas se escapan con \)
    //: en json significa clave-valor
    //BME280 es el valor que tendra sensor
  json += "\"sensor\":\"Temperatura\",";
    //bme.raedtEMPERATURE() este llama al sensor y devuelve un numero flotante(°C)
      //String(...) convierte ese numero en texto
  json += "\"temperature\":" + String(bme.readTemperature()) + ",";
    //llama al sensr pero para humedad
  json += "\"humidity\":" + String(bme.readHumidity()) + ",";
    //llama al sensor pero presion, en pascales y a su ves a hectopascales
  json += "\"pressure\":" + String(bme.readPressure() / 100.0F) + ",";
    //Lo mismo que las anteriores pero calcula la altitud aproximada usando la presión actual y la de referencia
  json += "\"altitude\":" + String(bme.readAltitude(SEALEVELPRESSURE_HPA));
  json += "}"; //cierre del json
  //Envia respuesta http, con el tipo de contenido que es json
  server.send(200, "application/json", json);
}

//Setup (Funcion que solo arranca una vez)
void setup() {
  //Inicia la comunicacion serial con la pc, a una velocidad de 115200
  Serial.begin(115200);
  //espera un milisegundo
  delay(1000);

  // --- Conexión Wi-Fi ---
  WiFi.begin(ssid, password); //Conectar con credenciales 
  Serial.println("Conectando a WiFi..."); //Escribe en la pantalla serial
  //Mientras no estemos conectaods al wifi, se repite el codigo de las llaves
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  //Una Vez esta conectado, nos muestra en pantalla esto:
  Serial.println("\nWiFi conectado!");
  Serial.print("IP del ESP32: "); Serial.println(WiFi.localIP());

  // --- Inicializar BME280 ---
  //Wire se encarga de manejar la comunicación I2C (bus de 2 cables)
  Wire.begin(19, 18); //SDA = 19, SCL = 18
if (!bme.begin(0x76, &Wire)) {  
  if (!bme.begin(0x77, &Wire)) {
    Serial.println("No se encontró el BME280 en 0x76 ni 0x77");
    while (1);
  }
}

//Mostramos en pantalla si se conecta correctamente el sig msj
  Serial.println("BME280 inicializado correctamente");

  // --- Configurar servidor ---
  server.on("/data-json", handleDataJSON); //Ruta donde se inicia esta función 
  server.begin(); //Arranca el servidor
  Serial.println("Servidor web iniciado en puerto 80"); //Imprime en el monitor serie el msj
}

//Funcion que no devuelve nada y esta en loop
void loop() {
  server.handleClient(); // Revisa si alguien entro al servidor
  // Muestra datos en Serial cada segundo (debug)
  Serial.print("Temp: "); Serial.print(bme.readTemperature()); Serial.print(" °C, ");
  Serial.print("Hum: "); Serial.print(bme.readHumidity()); Serial.print(" %, ");
  Serial.print("Presión: "); Serial.print(bme.readPressure() / 100.0F); Serial.println(" hPa");
  delay(1000);
}
Codigo Axel Versión1 (Arduino)🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑🛑:



Codigo de Johan (Arduino)🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸
#include <WiFi.h>
#include <WebServer.h>
#include <HardwareSerial.h>

// --- Wi-Fi ---
const char* ssid = "INFINITUM7BB2";
const char* password = "wvdK4gYDpW";

// --- Servidor web ---
WebServer server(80);

// --- PMS5003 ---
HardwareSerial pmsSerial(1);
#define PMS_RX 44
#define PMS_TX 43

struct pms5003data {
  uint16_t framelen;
  uint16_t pm10_standard, pm25_standard, pm100_standard;
  uint16_t pm10_env, pm25_env, pm100_env;
  uint16_t particles_03um, particles_05um, particles_10um, particles_25um, particles_50um, particles_100um;
  uint16_t unused;
  uint16_t checksum;
};

struct pms5003data data;

// --- Función que devuelve datos en JSON ---
void handleDataJSON() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  String json = "{";
  json += "\"sensor\":\"PMS5003\",";
  json += "\"pm25\":" + String(data.pm25_standard) + ",";
  json += "\"pm10\":" + String(data.pm100_standard) + ",";
  json += "\"particles_03um\":" + String(data.particles_03um) + ",";
  json += "\"particles_05um\":" + String(data.particles_05um) + ",";
  json += "\"particles_10um\":" + String(data.particles_10um) + ",";
  json += "\"particles_25um\":" + String(data.particles_25um) + ",";
  json += "\"particles_50um\":" + String(data.particles_50um) + ",";
  json += "\"particles_100um\":" + String(data.particles_100um);
  json += "}";
  server.send(200, "application/json", json);
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Conectar Wi-Fi
  WiFi.begin(ssid, password);
  Serial.println("Conectando a Wi-Fi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConectado!");
  Serial.print("IP asignada: "); Serial.println(WiFi.localIP());

  // Configurar servidor
  server.on("/data-json", handleDataJSON);
  server.begin();
  Serial.println("Servidor web iniciado");

  // Inicializar PMS5003
  pmsSerial.begin(9600, SERIAL_8N1, PMS_RX, PMS_TX);
  Serial.println("Esperando datos del PMS5003...");
}

void loop() {
  server.handleClient(); // Atiende solicitudes web

  // Leer PMS5003
  if (readPMSdata(&pmsSerial)) {
    Serial.print("\rPM2.5: "); Serial.print(data.pm25_standard);
    Serial.print("  PM10: "); Serial.print(data.pm100_standard);
    Serial.print("  Part >0.3um: "); Serial.print(data.particles_03um);
    Serial.print("  Part >0.5um: "); Serial.print(data.particles_05um);
    Serial.print("  Part >1.0um: "); Serial.print(data.particles_10um);
    Serial.print("  Part >2.5um: "); Serial.print(data.particles_25um);
    Serial.print("  Part >5.0um: "); Serial.print(data.particles_50um);
    Serial.print("  Part >10um: "); Serial.print(data.particles_100um);
  }

  delay(1000);
}

// --- Función de lectura PMS5003 ---
boolean readPMSdata(Stream *s) {
  if (!s->available()) return false;
  if (s->peek() != 0x42) { s->read(); return false; }
  if (s->available() < 32) return false;

  uint8_t buffer[32];
  uint16_t sum = 0;
  s->readBytes(buffer, 32);

  for (uint8_t i = 0; i < 30; i++) sum += buffer[i];

  uint16_t buffer_u16[15];
  for (uint8_t i = 0; i < 15; i++) {
    buffer_u16[i] = buffer[2 + i*2 + 1];
    buffer_u16[i] += (buffer[2 + i*2] << 8);
  }

  memcpy((void *)&data, (void *)buffer_u16, 30);

  if (sum != data.checksum) {
    Serial.println("Checksum failure");
    return false;
  }

  return true;
}
Codigo de Johan (Arduino)🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸🚸


UseEffect para sensores 🔥😈🔥😈🔥😈🔥🔥😈🔥😈🔥😈🔥🔥😈🔥😈🔥😈🔥

//Use Effect Johan ----
   useEffect(() => {
    //Funcion Asincronada (puede hacer coas que tardan en completarse)
        const fetchData = async () => {
        try {
        /* Con await, esperamos a que sea conectado el esp32 */
        const res = await fetch("http://192.168.1.97/data-json"); 
        //Convertimos los datos en un objeto JavaScript (Json)
        const data = await res.json();
        // Adaptamos el JSON a la interfaz Lectura[]
        //Creamos Una instancia del objeto "lectura"
        const nuevaLectura: Lectura = {
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: data.sensor,
          valor: data.pm25,
        };
        //Ir encadenando lecturas una atras de otra
        setLecturas((prev) => [...prev, nuevaLectura]); 
        await addDoc(collection(db,"lecturas"),{
        sensor: data.sensor, 
        valor: data.pm25,
        timestamp: nuevaLectura.timestamp,
        salon: "Salon A10",
        userId: user?.uid,
      }); 
      } catch (err) {
        console.error("Error al obtener datos:", err);
      }
    };
    // Llamamos cada 5 segundos
    const interval = setInterval(fetchData, 3000);
    return () => clearInterval(interval);
  }, []);


  //Use Effect Axel ----
  useEffect(()=>{
    const fetchData = async () =>{
      try {
        //Constante para conectarnos a la url del esp32
        const conexion = await fetch ("http://192.168.1.97/data-json");
        const dataBM280 = await conexion.json();

        const nuevaLecturaBM280: Lectura  ={
          timestamp: Timestamp.now(),
          id: Date.now().toString(),
          sensor: dataBM280.sensor,
          valor: dataBM280.temperature,
        };

        //Ir encadenanado Lecturas
        setLecturas(
          (prev) => [...prev, nuevaLecturaBM280]
        );

        //Agregar Lecturas a la coleccion:
        await addDoc(collection(db, "lecturasBM280"),{
          //Campos de la coleccion
          sensor: dataBM280.sensor,
          valor: dataBM280.temperature,
          Timestamp: nuevaLecturaBM280.timestamp,
          Lugar: "Morelia",
          userID: user?.uid,
        });
      } catch (error) {
        console.log("ocurrio un error caballero, es el siguiente: ", error);
      }
    };
    //Llamamos useEffect cada 5 segundos
    const interval = setInterval(fetchData, 3000);
    return () => clearInterval(interval);
  },[])

UseEffect para sensores 🔥😈🔥😈🔥😈🔥🔥😈🔥😈🔥😈🔥🔥😈🔥😈🔥😈🔥


Tareas Pendientes...〽〽〽
UseEffect Sensor de Temperatura... ✔
Alternar Entre UsEffects y botones para mostrar Tarjetas✔
Cambiar console.log a promps o alerts para que usuario sepa que pasa...✔
Boton de detener lecturas ...✔
Estilizar barra fea abajo de botones xD...✔
Agregar Columna para mencionarle al usuario como van las cosas✔
Refactorizar Codigo...
Botones Tomen Todo el color que les corresponde...
Footer



//instracciones para instalacion
0.-Descargar git
1.- Instalar el Node.js(Almenos la version 20)
2.- Ingresar en la terminal el npm run dev 
